<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>잠들지 않는 시간</title>
    <link>https://lisianthuss.github.io/</link>
    <description>Recent content on 잠들지 않는 시간</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 26 Mar 2020 14:11:52 +0900</lastBuildDate>
    
	<atom:link href="https://lisianthuss.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Docker</title>
      <link>https://lisianthuss.github.io/post/docker/</link>
      <pubDate>Thu, 26 Mar 2020 14:11:52 +0900</pubDate>
      
      <guid>https://lisianthuss.github.io/post/docker/</guid>
      <description>Docker 컨테이너 기반의 오픈소스 가상화 플랫폼
Container 격리된 공간에서 프로세스를 동작하는 기술
기존의 가상화 방식은 OS를 가상화하였다.
VMWare, Virtual Box 는 Host OS 위에 Guest OS 전체를 가상화하여 사용하는 방식이다.
여러가지 OS를 가상화하여 사용할 수 있지만 무겁고 느린 단점이 있다.
이러한 상황을 개선하기 위해 CPU의 가상화 기술(HVM)을 이용한 KVM(Kernel-Based Virtual Machine)과 반가상화(Paravirtualization) 방식의 Xen 이 등장하였다.
guest os가 필요하지만 전체 OS를 가상화하는 방식은 아니었기 때문에 host형 가상화 방식에 비해 성능이 향상되었다.</description>
    </item>
    
    <item>
      <title>OOP 커피 전문점</title>
      <link>https://lisianthuss.github.io/post/oop_coffee/</link>
      <pubDate>Fri, 06 Mar 2020 09:54:58 +0900</pubDate>
      
      <guid>https://lisianthuss.github.io/post/oop_coffee/</guid>
      <description>1. 커피 전문점에서 커피를 주문하는 과정을 객체들의 협력관계로 구현하자 객체들의 연관 관계 [손님 객체] &amp;mdash; 커피를 선택한다&amp;mdash; [메뉴판 객체(아메리카노, 라떼)]
___|
___| 바리스타에서 커피를 주문한다
___|
[바리스타 객체] &amp;mdash; 커피를 제조한다 &amp;mdash; [아메리카노 객체, 카푸치노 객체, 라떼 객체]
2. 설계하기  협력을 설계할 때에는 객체가 메시지를 선택하는 것이 아니라, 메시지가 객체를 선택하게 해야 한다.
&amp;ndash; 메시지를 먼저 선택하고, 그 후에 메시지를 수신하기에 적절한 객체를 선택해야 한다. 할당된 책임을 수행하는 도중에 스스로 할 수 없는 일이 있다면, 다른 객체에 요청해야 한다.</description>
    </item>
    
    <item>
      <title>Composite Pattern</title>
      <link>https://lisianthuss.github.io/post/composite_pattern/</link>
      <pubDate>Tue, 03 Mar 2020 13:22:14 +0900</pubDate>
      
      <guid>https://lisianthuss.github.io/post/composite_pattern/</guid>
      <description>전체-부분의 관계를 갖는 객체들 사이의 관계를 정의할 때 유용
클라이언트는 전체와 부분을 구분하지 않고 동일한 인터페이스를 사용할 수 있다.
  Component
&amp;ndash; Leaf 클래스와 전체에 해당하는 Composite 클래스에 공통 인터페이스를 정의한다. Leaf
&amp;ndash; Composite 객체의 부품으로 설정한다 Composite
&amp;ndash; 전체 클래스로 복수 개의 Compoenet를 갖도록 정의한다. &amp;ndash; 복수 개의 Leaf, Composite 객체를 부분으로 가질 수 있다.  예제 ( 컴퓨터에 추가 장치 지원하기 ) 컴퓨터의 구성 장치를 Keyboard, Body, Monitor 클래스로 정의할 수 있다.</description>
    </item>
    
    <item>
      <title>Abstract Factory Pattern</title>
      <link>https://lisianthuss.github.io/post/abstract_factory_pattern/</link>
      <pubDate>Tue, 03 Mar 2020 13:03:21 +0900</pubDate>
      
      <guid>https://lisianthuss.github.io/post/abstract_factory_pattern/</guid>
      <description>관련성 있는 여러 종류의 객체를 일관성 있는 방식으로 생성할 때 유용
  AbstractFactory
&amp;ndash; factory 클래스의 공통 인터페이스
&amp;ndash; 각 제품의 부품을 생성하는 기능을 추상 method로 정의한다. ConcreteFactory
&amp;ndash; AbstractFactory 클래스의 abstrace method를 override 해서 prodct를 만든다. AbstractProduct
&amp;ndash; product 의 공통 인터페이스 ConcreteProduct
&amp;ndash; factory 에서 생성되는 객체  예제 ( 엘리베이터 부품 업체 변경하기 ) 엘리베이터를 구성하는 부품 중 모터와 문을 예를 들어보자.
각 제조업체별로 모터와 문을 생산한다.</description>
    </item>
    
    <item>
      <title>Factory Method Pattern</title>
      <link>https://lisianthuss.github.io/post/factory_method_pattern/</link>
      <pubDate>Tue, 03 Mar 2020 12:47:00 +0900</pubDate>
      
      <guid>https://lisianthuss.github.io/post/factory_method_pattern/</guid>
      <description>객체를 생성하는 코드를 별도의 class/method로 분리함으로써 객체 생성 방식의 변화를 대비하는데 유용
  Product
&amp;ndash; factory method로 생성될 객체의 공통 클래스 ConcreteProduct
&amp;ndash; 객체가 생성되는 클래스 Creator
&amp;ndash; factory method를 갖는 클래스 ConcreteCreator
&amp;ndash; factory method를 구현하는 클래스로 ConcreteProduct 객체를 생성한다  예제 ( 여러가지 방식의 엘리베이터 스케줄링 방법 지원하기 ) 여러 대의 엘리베이터가 있는 경우, 버튼을 눌렀을 때 하나의 엘리베이터를 선택하여 이동시킨다.
 어떤 엘리베이터를 이동시킬지 결정하는 여러 스케줄링 방법을 적용한다.</description>
    </item>
    
    <item>
      <title>Template Method Pattern</title>
      <link>https://lisianthuss.github.io/post/template_method_pattern/</link>
      <pubDate>Tue, 03 Mar 2020 12:34:39 +0900</pubDate>
      
      <guid>https://lisianthuss.github.io/post/template_method_pattern/</guid>
      <description>전체적인 알고리즘은 상위 클래스에 구현하면서 다른 부분은 하위 클래스에서 구현할 수 있도록 하는 패턴
 언제 사용하지? 전체적으로는 동일하면서 부분적으로는 다른 구문으로 구성된 method의 코드 중복을 최소화할 때 유용
예제 ( 여러 회사 모터 지원하기 ) 엘리베이터 제어 시스템에서 모터를 구동시키는 기능을 구현하자.
 엘리베이터가 이동 중이면 모터를 구동시키지 않는다.  현대 모터를 사용하여 문을 제어한다면 다음과 같이 설계할 수 있다.
enum DoorStatus { CLOSED, OPENED } enum MotorStatus { MOVING, STOPPED } class Door { public: Door() { doorStatus = CLOSED; } DoorStatus getDoorStatus() { return doorStatus; } void close() { doorStatus = CLOSED; } void open() { doorStatus = OPENED; } private: DoorStatus doorStatus; }; class HyundaiMotor { public: HyundaiMotor(Door* door) { this-&amp;gt;door = door; motorStatus = STOPPED; } MotorStatus getMotorStatus() { return motorStatus; } void move(Direction direction) { if (getMotorStatus() == MOVING) { return; } if (door.</description>
    </item>
    
    <item>
      <title>Decorator Pattern</title>
      <link>https://lisianthuss.github.io/post/decorator_pattern/</link>
      <pubDate>Tue, 03 Mar 2020 11:59:45 +0900</pubDate>
      
      <guid>https://lisianthuss.github.io/post/decorator_pattern/</guid>
      <description>기본 기능에 추가할 수 있는 많은 종류의 부가 기능에서 파생되는 다양한 조합을 동적으로 구현할 수 있는 패턴
 언제 사용하지?  기본 기능에 추가할 수 있는 기능의 종류가 많은 경우, 각 추가 기능을 Decorator 클래스로 정의한 후 필요한 Decorator 객체를 조합하여 추가 기능의 조합을 설계하는 방식   Component
&amp;ndash; 기본 기능을 뜻하는 ComcreteComponent와 추가 기능을 뜻하는 Decorator의 공통 기능을 정의
&amp;ndash; 즉 클라이언트는 Component를 통해 실제 객체를 사용한다. ConcreteComponent</description>
    </item>
    
    <item>
      <title>Command Pattern</title>
      <link>https://lisianthuss.github.io/post/command_pattern/</link>
      <pubDate>Tue, 03 Mar 2020 11:06:56 +0900</pubDate>
      
      <guid>https://lisianthuss.github.io/post/command_pattern/</guid>
      <description>실행될 기능을 캡슐화하여, 기능 실행을 요구하는 호출자(Invoker) 클래스와, 실제 기능을 수행하는 수신자(Receiver) 클래스 사이의 의존성을 제거한다.
따라서 실행될 기능의 변경에도 호출자 클래스를 수정 없이 그대로 사용할 수 있다.
 언제 사용하지? 이벤트가 발생했을 때 실행될 기능이 다양하면서도 변경이 필요한 경우, 이벤트를 발생시키는 클래스를 변경하지 않고 재사용하고자 할 때 유용하다.
 Command
&amp;ndash; 실행될 기능에 대한 인터페이스. 실행될 기능을 execute method로 선언함. ConcreteCommand
&amp;ndash; 실제로 실행되는 기능을 구현. Invoker
&amp;ndash; 기능의 실행을 요청하는 호출자 클래스 Receiver</description>
    </item>
    
    <item>
      <title>State Pattern</title>
      <link>https://lisianthuss.github.io/post/state_pattern/</link>
      <pubDate>Tue, 03 Mar 2020 09:53:50 +0900</pubDate>
      
      <guid>https://lisianthuss.github.io/post/state_pattern/</guid>
      <description>상황에 따라 동일한 작업이 다른 방식으로 실행될 때, 해당 상태가 작업을 수행하도록 위임하는 디자인 패턴이다.
 일을 수행할 때 상태 하나하나가 어떤 상태인지 확인해서 일을 다르게 수행한다면?  복잡한 조건식이 있는 코드가 만들어진다. 코드를 이해하거나 수정하기 어렵게 된다.  State Pattern을 사용하려면? 어떤 행위를 해야할 때, 상태에 행위를 수행하도록 위임한다
 시스템의 각 상태를 클래스로 분리해 표현 각 클래서에서 수행하는 행위들을 method로 구현 외부로부터 캡슐화하기 위해 인터페이스 생성 시스템의 각 상태를 나타내는 클래스가 실체화하게 한다.</description>
    </item>
    
    <item>
      <title>Singleton Pattern</title>
      <link>https://lisianthuss.github.io/post/singleton_pattern/</link>
      <pubDate>Tue, 03 Mar 2020 09:28:31 +0900</pubDate>
      
      <guid>https://lisianthuss.github.io/post/singleton_pattern/</guid>
      <description>인스턴스가 하나만 생성되는 것을 보장하며 어디에서든 이 인스턴스에 접근할 수 있는 디자인 패턴이다
 예제 ( 프린터 관리자 만들기 ) 1. 단 하나의 프린터(객체)만 생성해 어디서든 참조할 수 있게 해보자. new Printer() 가 호출되지 않도록 생성자를 private로 변경하고, 한 번만 호출되도록 getPrinter에 static 속성을 부여하면, Printer 인스턴스가 생성된 상황이라면 그 인스턴스를 반환하며, 없다면 새로 생성해서 반환한다.
public class Printer { private static Printer printer = null; private Printer() {} public static Printer getPrinter() { if (printer == null) printer = new Printer(); return printer; } public void print(Resource r) { .</description>
    </item>
    
    <item>
      <title>Strategy Pattern</title>
      <link>https://lisianthuss.github.io/post/strategy_pattern/</link>
      <pubDate>Tue, 03 Mar 2020 08:50:15 +0900</pubDate>
      
      <guid>https://lisianthuss.github.io/post/strategy_pattern/</guid>
      <description>같은 문제를 해결하는 여러 알고리즘이 클래스별로 캡슐화되어 있고, 필요할 때 교체할 수 있도록 함으로써 동일한 문제를 다른 알고리즘으로 해결할 수 있게 하는 디자인 패턴이다.
  Strategy
&amp;ndash; 인터페이스나 추상 클래스, 외부에도 동일한 방식으로 호출하는 방식을 명시 ConcreteStrategy
&amp;ndash; 알고리즘을 실제로 구현 Context
&amp;ndash; strategy 패턴을 실제로 이용. 동적으로 전략을 바꾸도록 setter method 제공  예제 ( 로봇 만들기 ) 1. 기본 설계 공격과이동이 가능한 태권v와 아톰을 위와 같이 설계할 수 있다.</description>
    </item>
    
  </channel>
</rss>