<!DOCTYPE html>
<html lang="en-us">
    <head>
	<meta name="generator" content="Hugo 0.65.3" />
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
			<meta name="description" content="">

		<title>잠들지 않는 시간</title>

		
  		<link rel="stylesheet" href="/css/style.css">
		<link rel="stylesheet" href="/css/fonts.css">
		
		<link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
		<link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
		<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

		
		<link href="/index.xml" rel="alternate" type="application/rss+xml" title="잠들지 않는 시간" />
	</head>

    <body>
        		<nav class="nav">
			<div class="nav-container">
				<a href="/">
					<h2 class="nav-title">잠들지 않는 시간</h2>
				</a>
				<ul>
    
    
        <li>
            <a href="/about/">
                
                <span>About</span>
                
            </a>
        </li>
    
        <li>
            <a href="/post/">
                
                <span>Posts</span>
                
            </a>
        </li>
    
</ul>
			</div>
		</nav>

        

<main>
	


	<div class="catalogue">
		
			<a href="https://lisianthuss.github.io/post/oop_coffee/" class="catalogue-item">
    <div>
        <time datetime="2020-03-06 09:54:58 &#43;0900 KST" class="catalogue-time">March 6, 2020</time>
        <h1 class="catalogue-title">OOP 커피 전문점</h1>
        <div class="catalogue-line"></div>

        <p>
            1. 커피 전문점에서 커피를 주문하는 과정을 객체들의 협력관계로 구현하자 객체들의 연관 관계 [손님 객체] &mdash; 커피를 선택한다&mdash; [메뉴판 객체(아메리카노, 라떼)]
___|
___| 바리스타에서 커피를 주문한다
___|
[바리스타 객체] &mdash; 커피를 제조한다 &mdash; [아메리카노 객체, 카푸치노 객체, 라떼 객체]
2. 설계하기  협력을 설계할 때에는 객체가 메시지를 선택하는 것이 아니라, 메시지가 객체를 선택하게 해야 한다.
&ndash; 메시지를 먼저 선택하고, 그 후에 메시지를 수신하기에 적절한 객체를 선택해야 한다. 할당된 책임을 수행하는 도중에 스스로 할 수 없는 일이 있다면, 다른 객체에 요청해야 한다.
        </p>
    </div>
</a>

		
			<a href="https://lisianthuss.github.io/post/abstract_factory_pattern/" class="catalogue-item">
    <div>
        <time datetime="2020-03-03 13:03:21 &#43;0900 KST" class="catalogue-time">March 3, 2020</time>
        <h1 class="catalogue-title">Abstract Factory Pattern</h1>
        <div class="catalogue-line"></div>

        <p>
            관련성 있는 여러 종류의 객체를 일관성 있는 방식으로 생성할 때 유용
  AbstractFactory
&ndash; factory 클래스의 공통 인터페이스
&ndash; 각 제품의 부품을 생성하는 기능을 추상 method로 정의한다. ConcreteFactory
&ndash; AbstractFactory 클래스의 abstrace method를 override 해서 prodct를 만든다. AbstractProduct
&ndash; product 의 공통 인터페이스 ConcreteProduct
&ndash; factory 에서 생성되는 객체  예제 ( 엘리베이터 부품 업체 변경하기 ) 엘리베이터를 구성하는 부품 중 모터와 문을 예를 들어보자.
각 제조업체별로 모터와 문을 생산한다.
        </p>
    </div>
</a>

		
			<a href="https://lisianthuss.github.io/post/factory_method_pattern/" class="catalogue-item">
    <div>
        <time datetime="2020-03-03 12:47:00 &#43;0900 KST" class="catalogue-time">March 3, 2020</time>
        <h1 class="catalogue-title">Factory Method Pattern</h1>
        <div class="catalogue-line"></div>

        <p>
            객체를 생성하는 코드를 별도의 class/method로 분리함으로써 객체 생성 방식의 변화를 대비하는데 유용
  Product
&ndash; factory method로 생성될 객체의 공통 클래스 ConcreteProduct
&ndash; 객체가 생성되는 클래스 Creator
&ndash; factory method를 갖는 클래스 ConcreteCreator
&ndash; factory method를 구현하는 클래스로 ConcreteProduct 객체를 생성한다  예제 ( 여러가지 방식의 엘리베이터 스케줄링 방법 지원하기 ) 여러 대의 엘리베이터가 있는 경우, 버튼을 눌렀을 때 하나의 엘리베이터를 선택하여 이동시킨다.
 어떤 엘리베이터를 이동시킬지 결정하는 여러 스케줄링 방법을 적용한다.
        </p>
    </div>
</a>

		
			<a href="https://lisianthuss.github.io/post/template_method_pattern/" class="catalogue-item">
    <div>
        <time datetime="2020-03-03 12:34:39 &#43;0900 KST" class="catalogue-time">March 3, 2020</time>
        <h1 class="catalogue-title">Template Method Pattern</h1>
        <div class="catalogue-line"></div>

        <p>
            전체적인 알고리즘은 상위 클래스에 구현하면서 다른 부분은 하위 클래스에서 구현할 수 있도록 하는 패턴
 언제 사용하지? 전체적으로는 동일하면서 부분적으로는 다른 구문으로 구성된 method의 코드 중복을 최소화할 때 유용
예제 ( 여러 회사 모터 지원하기 ) 엘리베이터 제어 시스템에서 모터를 구동시키는 기능을 구현하자.
 엘리베이터가 이동 중이면 모터를 구동시키지 않는다.  현대 모터를 사용하여 문을 제어한다면 다음과 같이 설계할 수 있다.
enum DoorStatus { CLOSED, OPENED } enum MotorStatus { MOVING, STOPPED } class Door { public: Door() { doorStatus = CLOSED; } DoorStatus getDoorStatus() { return doorStatus; } void close() { doorStatus = CLOSED; } void open() { doorStatus = OPENED; } private: DoorStatus doorStatus; }; class HyundaiMotor { public: HyundaiMotor(Door* door) { this-&gt;door = door; motorStatus = STOPPED; } MotorStatus getMotorStatus() { return motorStatus; } void move(Direction direction) { if (getMotorStatus() == MOVING) { return; } if (door.
        </p>
    </div>
</a>

		
			<a href="https://lisianthuss.github.io/post/decorator_pattern/" class="catalogue-item">
    <div>
        <time datetime="2020-03-03 11:59:45 &#43;0900 KST" class="catalogue-time">March 3, 2020</time>
        <h1 class="catalogue-title">Decorator Pattern</h1>
        <div class="catalogue-line"></div>

        <p>
            기본 기능에 추가할 수 있는 많은 종류의 부가 기능에서 파생되는 다양한 조합을 동적으로 구현할 수 있는 패턴
 언제 사용하지?  기본 기능에 추가할 수 있는 기능의 종류가 많은 경우, 각 추가 기능을 Decorator 클래스로 정의한 후 필요한 Decorator 객체를 조합하여 추가 기능의 조합을 설계하는 방식   Component
&ndash; 기본 기능을 뜻하는 ComcreteComponent와 추가 기능을 뜻하는 Decorator의 공통 기능을 정의
&ndash; 즉 클라이언트는 Component를 통해 실제 객체를 사용한다. ConcreteComponent
        </p>
    </div>
</a>

		
			<a href="https://lisianthuss.github.io/post/command_pattern/" class="catalogue-item">
    <div>
        <time datetime="2020-03-03 11:06:56 &#43;0900 KST" class="catalogue-time">March 3, 2020</time>
        <h1 class="catalogue-title">Command Pattern</h1>
        <div class="catalogue-line"></div>

        <p>
            실행될 기능을 캡슐화하여, 기능 실행을 요구하는 호출자(Invoker) 클래스와, 실제 기능을 수행하는 수신자(Receiver) 클래스 사이의 의존성을 제거한다.
따라서 실행될 기능의 변경에도 호출자 클래스를 수정 없이 그대로 사용할 수 있다.
 언제 사용하지? 이벤트가 발생했을 때 실행될 기능이 다양하면서도 변경이 필요한 경우, 이벤트를 발생시키는 클래스를 변경하지 않고 재사용하고자 할 때 유용하다.
 Command
&ndash; 실행될 기능에 대한 인터페이스. 실행될 기능을 execute method로 선언함. ConcreteCommand
&ndash; 실제로 실행되는 기능을 구현. Invoker
&ndash; 기능의 실행을 요청하는 호출자 클래스 Receiver
        </p>
    </div>
</a>

		
			<a href="https://lisianthuss.github.io/post/state_pattern/" class="catalogue-item">
    <div>
        <time datetime="2020-03-03 09:53:50 &#43;0900 KST" class="catalogue-time">March 3, 2020</time>
        <h1 class="catalogue-title">State Pattern</h1>
        <div class="catalogue-line"></div>

        <p>
            상황에 따라 동일한 작업이 다른 방식으로 실행될 때, 해당 상태가 작업을 수행하도록 위임하는 디자인 패턴이다.
 일을 수행할 때 상태 하나하나가 어떤 상태인지 확인해서 일을 다르게 수행한다면?  복잡한 조건식이 있는 코드가 만들어진다. 코드를 이해하거나 수정하기 어렵게 된다.  State Pattern을 사용하려면? 어떤 행위를 해야할 때, 상태에 행위를 수행하도록 위임한다
 시스템의 각 상태를 클래스로 분리해 표현 각 클래서에서 수행하는 행위들을 method로 구현 외부로부터 캡슐화하기 위해 인터페이스 생성 시스템의 각 상태를 나타내는 클래스가 실체화하게 한다.
        </p>
    </div>
</a>

		
			<a href="https://lisianthuss.github.io/post/singleton_pattern/" class="catalogue-item">
    <div>
        <time datetime="2020-03-03 09:28:31 &#43;0900 KST" class="catalogue-time">March 3, 2020</time>
        <h1 class="catalogue-title">Singleton Pattern</h1>
        <div class="catalogue-line"></div>

        <p>
            인스턴스가 하나만 생성되는 것을 보장하며 어디에서든 이 인스턴스에 접근할 수 있는 디자인 패턴이다
 예제 ( 프린터 관리자 만들기 ) 1. 단 하나의 프린터(객체)만 생성해 어디서든 참조할 수 있게 해보자. new Printer() 가 호출되지 않도록 생성자를 private로 변경하고, 한 번만 호출되도록 getPrinter에 static 속성을 부여하면, Printer 인스턴스가 생성된 상황이라면 그 인스턴스를 반환하며, 없다면 새로 생성해서 반환한다.
public class Printer { private static Printer printer = null; private Printer() {} public static Printer getPrinter() { if (printer == null) printer = new Printer(); return printer; } public void print(Resource r) { .
        </p>
    </div>
</a>

		
			<a href="https://lisianthuss.github.io/post/strategy_pattern/" class="catalogue-item">
    <div>
        <time datetime="2020-03-03 08:50:15 &#43;0900 KST" class="catalogue-time">March 3, 2020</time>
        <h1 class="catalogue-title">Strategy Pattern</h1>
        <div class="catalogue-line"></div>

        <p>
            같은 문제를 해결하는 여러 알고리즘이 클래스별로 캡슐화되어 있고, 필요할 때 교체할 수 있도록 함으로써 동일한 문제를 다른 알고리즘으로 해결할 수 있게 하는 디자인 패턴이다.
  Strategy
&ndash; 인터페이스나 추상 클래스, 외부에도 동일한 방식으로 호출하는 방식을 명시 ConcreteStrategy
&ndash; 알고리즘을 실제로 구현 Context
&ndash; strategy 패턴을 실제로 이용. 동적으로 전략을 바꾸도록 setter method 제공  예제 ( 로봇 만들기 ) 1. 기본 설계 공격과이동이 가능한 태권v와 아톰을 위와 같이 설계할 수 있다.
        </p>
    </div>
</a>

		
	</div>

	<div class="pagination">
		
		

		<span>1</span>
	</div>
</main>


        		<footer>
			<span>
			&copy; <time datetime="2020-03-09 20:02:28.318549 &#43;0900 KST m=&#43;0.123098249">2020</time> . Made with <a href='https://gohugo.io'>Hugo</a> using the <a href='https://github.com/EmielH/tale-hugo/'>Tale</a> theme.
			</span>
		</footer>

    </body>
</html>
