<!DOCTYPE html>
<html lang="en-us">
    <head>
	<meta name="generator" content="Hugo 0.65.3" />
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
			<meta name="description" content="">

		<title>잠들지 않는 시간</title>

		
  		<link rel="stylesheet" href="/css/style.css">
		<link rel="stylesheet" href="/css/fonts.css">
		
		<link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
		<link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
		<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

		
		<link href="/index.xml" rel="alternate" type="application/rss+xml" title="잠들지 않는 시간" />
	</head>

    <body>
        		<nav class="nav">
			<div class="nav-container">
				<a href="/">
					<h2 class="nav-title">잠들지 않는 시간</h2>
				</a>
				<ul>
    
    
        <li>
            <a href="/about/">
                
                <span>About</span>
                
            </a>
        </li>
    
        <li>
            <a href="/post/">
                
                <span>Posts</span>
                
            </a>
        </li>
    
</ul>
			</div>
		</nav>

        

<main>
	


	<div class="catalogue">
		
			<a href="https://lisianthuss.github.io/post/oop_coffee/" class="catalogue-item">
    <div>
        <time datetime="2020-03-06 09:54:58 &#43;0900 KST" class="catalogue-time">March 6, 2020</time>
        <h1 class="catalogue-title">OOP 커피 전문점</h1>
        <div class="catalogue-line"></div>

        <p>
            1. 커피 전문점에서 커피를 주문하는 과정을 객체들의 협력관계로 구현하자 객체들의 연관 관계 [손님 객체] &mdash; 커피를 선택한다&mdash; [메뉴판 객체(아메리카노, 라떼)]
___|
___| 바리스타에서 커피를 주문한다
___|
[바리스타 객체] &mdash; 커피를 제조한다 &mdash; [아메리카노 객체, 카푸치노 객체, 라떼 객체]
2. 설계하기  협력을 설계할 때에는 객체가 메시지를 선택하는 것이 아니라, 메시지가 객체를 선택하게 해야 한다.
&ndash; 메시지를 먼저 선택하고, 그 후에 메시지를 수신하기에 적절한 객체를 선택해야 한다. 할당된 책임을 수행하는 도중에 스스로 할 수 없는 일이 있다면, 다른 객체에 요청해야 한다.
        </p>
    </div>
</a>

		
			<a href="https://lisianthuss.github.io/post/command_pattern/" class="catalogue-item">
    <div>
        <time datetime="2020-03-03 11:06:56 &#43;0900 KST" class="catalogue-time">March 3, 2020</time>
        <h1 class="catalogue-title">Command Pattern</h1>
        <div class="catalogue-line"></div>

        <p>
            실행될 기능을 캡슐화하여, 기능 실행을 요구하는 호출자(Invoker) 클래스와, 실제 기능을 수행하는 수신자(Receiver) 클래스 사이의 의존성을 제거한다.
따라서 실행될 기능의 변경에도 호출자 클래스를 수정 없이 그대로 사용할 수 있다.
 언제 사용하지? 이벤트가 발생했을 때 실행될 기능이 다양하면서도 변경이 필요한 경우, 이벤트를 발생시키는 클래스를 변경하지 않고 재사용하고자 할 때 유용하다.
 Command
&ndash; 실행될 기능에 대한 인터페이스. 실행될 기능을 execute method로 선언함. ConcreteCommand
&ndash; 실제로 실행되는 기능을 구현. Invoker
&ndash; 기능의 실행을 요청하는 호출자 클래스 Receiver
        </p>
    </div>
</a>

		
			<a href="https://lisianthuss.github.io/post/state_pattern/" class="catalogue-item">
    <div>
        <time datetime="2020-03-03 09:53:50 &#43;0900 KST" class="catalogue-time">March 3, 2020</time>
        <h1 class="catalogue-title">State Pattern</h1>
        <div class="catalogue-line"></div>

        <p>
            상황에 따라 동일한 작업이 다른 방식으로 실행될 때, 해당 상태가 작업을 수행하도록 위임하는 디자인 패턴이다.
 일을 수행할 때 상태 하나하나가 어떤 상태인지 확인해서 일을 다르게 수행한다면?  복잡한 조건식이 있는 코드가 만들어진다. 코드를 이해하거나 수정하기 어렵게 된다.  State Pattern을 사용하려면? 어떤 행위를 해야할 때, 상태에 행위를 수행하도록 위임한다
 시스템의 각 상태를 클래스로 분리해 표현 각 클래서에서 수행하는 행위들을 method로 구현 외부로부터 캡슐화하기 위해 인터페이스 생성 시스템의 각 상태를 나타내는 클래스가 실체화하게 한다.
        </p>
    </div>
</a>

		
			<a href="https://lisianthuss.github.io/post/singleton_pattern/" class="catalogue-item">
    <div>
        <time datetime="2020-03-03 09:28:31 &#43;0900 KST" class="catalogue-time">March 3, 2020</time>
        <h1 class="catalogue-title">Singleton Pattern</h1>
        <div class="catalogue-line"></div>

        <p>
            인스턴스가 하나만 생성되는 것을 보장하며 어디에서든 이 인스턴스에 접근할 수 있는 디자인 패턴이다
 예제 ( 프린터 관리자 만들기 ) 1. 단 하나의 프린터(객체)만 생성해 어디서든 참조할 수 있게 해보자. new Printer() 가 호출되지 않도록 생성자를 private로 변경하고, 한 번만 호출되도록 getPrinter에 static 속성을 부여하면, Printer 인스턴스가 생성된 상황이라면 그 인스턴스를 반환하며, 없다면 새로 생성해서 반환한다.
public class Printer { private static Printer printer = null; private Printer() {} public static Printer getPrinter() { if (printer == null) printer = new Printer(); return printer; } public void print(Resource r) { .
        </p>
    </div>
</a>

		
			<a href="https://lisianthuss.github.io/post/strategy_pattern/" class="catalogue-item">
    <div>
        <time datetime="2020-03-03 08:50:15 &#43;0900 KST" class="catalogue-time">March 3, 2020</time>
        <h1 class="catalogue-title">Strategy Pattern</h1>
        <div class="catalogue-line"></div>

        <p>
            같은 문제를 해결하는 여러 알고리즘이 클래스별로 캡슐화되어 있고, 필요할 때 교체할 수 있도록 함으로써 동일한 문제를 다른 알고리즘으로 해결할 수 있게 하는 디자인 패턴이다.
  Strategy
&ndash; 인터페이스나 추상 클래스, 외부에도 동일한 방식으로 호출하는 방식을 명시 ConcreteStrategy
&ndash; 알고리즘을 실제로 구현 Context
&ndash; strategy 패턴을 실제로 이용. 동적으로 전략을 바꾸도록 setter method 제공  예제 ( 로봇 만들기 ) 1. 기본 설계 공격과이동이 가능한 태권v와 아톰을 위와 같이 설계할 수 있다.
        </p>
    </div>
</a>

		
	</div>

	<div class="pagination">
		
		

		<span>1</span>
	</div>
</main>


        		<footer>
			<span>
			&copy; <time datetime="2020-03-07 17:28:04.166794 &#43;0900 KST m=&#43;0.145039437">2020</time> . Made with <a href='https://gohugo.io'>Hugo</a> using the <a href='https://github.com/EmielH/tale-hugo/'>Tale</a> theme.
			</span>
		</footer>

    </body>
</html>
